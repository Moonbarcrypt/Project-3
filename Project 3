#include <iostream>
#include <string>
#include <stack>
#include <map>

/**
 * Checks if a string containing braces, parentheses, and brackets is
 * properly delimited using a single stack.
 *
 * @param s The string to check, potentially containing '()', '{}', and '[]'.
 * @return True if the string is properly delimited, False otherwise.
 */
bool isProperlyDelimited(const std::string& s) {
    std::stack<char> st;
    // Map closing delimiters to their required openers
    std::map<char, char> d_map = {
        {')', '('}, 
        {'}', '{'}, 
        {']', '['}
    };
    
    // Define the set of opening delimiters for efficiency
    std::string open_delimiters = "([{"; 

    for (char const& c : s) {
        if (open_delimiters.find(c) != std::string::npos) {
            // Found an opening delimiter, push it
            st.push(c);
        } else if (d_map.count(c)) {
            // Found a closing delimiter
            if (st.empty() || st.top() != d_map[c]) {
                // Error: Stack is empty (unmatched closing) or mismatch found
                return false;
            }
            // Match found, pop the opener
            st.pop();
        }
        // Ignore all other characters
    }
            
    // Result is valid if and only if the stack is empty at the end
    return st.empty();
}

int main() {
    // --- Test Cases ---
    std::string test_cases[] = {
        // Valid Cases
        "{[()]()}",                   
        "()[]{}{}",                   
        "([{}])",                     

        // Invalid Cases
        "([)]",                       
        "((",                         
        "}",                          
        "{[",                         
        "[{(})]",                     
    };

    std::cout << "--- Delimiter Checker Program Start (C++ Version) ---\n";
    
    for (const std::string& case_str : test_cases) {
        bool result = isProperlyDelimited(case_str);
        // Using a simple output format
        std::cout << "'" << case_str << "': " 
                  << (result ? "VALID" : "INVALID") 
                  << "\n";
    }

    return 0;
}
